%{
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <map>
#include <vector>
#include <cassert>
#include "config-host.h"
#include "tfg/edge_guard.h"
#include "graph/edge_id.h"
#include "tfg/tfg.h"
#include "eq/corr_graph.h"
#include "support/pool.h"

using namespace std;

int cglex();
int cgparse();

int cg_scan_string(const char*);
void cgpop_buffer_state();

void cgerror(const char *p);
//corr_graph const *cg_tfg;
pool<pcpair> cg_pc_pool;
pool<graph_edge_composition_ref<pcpair,edge_id_t<pcpair>>> cg_ec_pool;
pool_id_t cg_cur_ec;

%}

%name-prefix "cg"

%union {
  char* str;
  int num;
};

%token LBRAC RBRAC ARROW LABEL STAR PLUS UNMATCHED LABEL_EPSILON

%type<str> LABEL
%type<str> LABEL_EPSILON
%type<num> edge_composition
%type<num> label

%locations

%%
edge_composition:
	  LBRAC label ARROW label RBRAC
          {
             pcpair const &from_pc = cg_pc_pool.get($2);
             pcpair const &to_pc = cg_pc_pool.get($4);
             edge_id_t<pcpair> e(from_pc,to_pc);
             cg_cur_ec = cg_ec_pool.reg_elem(mk_edge_composition<pcpair,edge_id_t<pcpair>>(e));
             $$ = cg_cur_ec;
          }
        | LBRAC edge_composition STAR edge_composition RBRAC
          {
            graph_edge_composition_ref<pcpair,edge_id_t<pcpair>> const &e1 = cg_ec_pool.get($2);
            graph_edge_composition_ref<pcpair,edge_id_t<pcpair>> const &e2 = cg_ec_pool.get($4);
            cg_cur_ec = cg_ec_pool.reg_elem(mk_series<pcpair,edge_id_t<pcpair>>(e1, e2));
            $$ = cg_cur_ec;
          }
        | LBRAC edge_composition PLUS edge_composition RBRAC
          {
            graph_edge_composition_ref<pcpair,edge_id_t<pcpair>> const &e1 = cg_ec_pool.get($2);
            graph_edge_composition_ref<pcpair,edge_id_t<pcpair>> const &e2 = cg_ec_pool.get($4);
            cg_cur_ec = cg_ec_pool.reg_elem(graph_edge_composition_construct_edge_from_parallel_edges<pcpair,edge_id_t<pcpair>>({ e1, e2 })); // mk_parallel does not preserve epsilon
            $$ = cg_cur_ec;
          }
        | LBRAC LABEL_EPSILON RBRAC
          {
             cg_cur_ec = cg_ec_pool.reg_elem(mk_epsilon_ec<pcpair,edge_id_t<pcpair>>());
             $$ = cg_cur_ec;
          }
;

label:   LABEL
         {
           pool_id_t ret = cg_pc_pool.reg_elem(pcpair::create_from_string($1));
           free($1);
           $$ = ret;
         }
%%

namespace eqspace {

graph_edge_composition_ref<pcpair,edge_id_t<pcpair>>
parse_cg_edge_composition(const char* str)
{
  //cg_tfg = cg;
// ltsin = stdin; // either use FD or yy_scan_string and yypop_buffer_state
// second one for cleaning the copy of str generated by flex
  cg_scan_string(str);

  int rc = cgparse();

  cgpop_buffer_state();
  graph_edge_composition_ref<pcpair,edge_id_t<pcpair>> ret = cg_ec_pool.get(cg_cur_ec);
  cg_pc_pool.free_elems();
  cg_ec_pool.free_elems();
  return ret;
}

}

void cgerror(const char* str)
{
  cerr << __func__ << " " << __LINE__ << ": Error! str = " << str << endl; assert(false);
}
