%{
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <map>
#include <vector>
#include <cassert>
#include "config-host.h"
#include "graph/edge_id.h"
#include "gsupport/tfg_edge.h"
#include "support/pool.h"

using namespace std;

int eglex();
int egparse();

int eg_scan_string(const char*);
void egpop_buffer_state();

void egerror(const char *p);
//tfg const *eg_tfg;
pool<pc> eg_pc_pool;
pool<graph_edge_composition_ref<pc,edge_id_t<pc>>> eg_ec_pool;
pool_id_t eg_cur_ec;

%}

%name-prefix "eg"

%union {
  char* str;
  int num;
};

%token LBRAC RBRAC ARROW LABEL_INTERNAL LABEL_EXIT STAR PLUS UNMATCHED LABEL_EPSILON

%type<str> LABEL_INTERNAL
%type<str> LABEL_EXIT
%type<str> LABEL_EPSILON
%type<num> edge_composition
%type<num> label

%locations

%%
edge_composition:
	  LBRAC label ARROW label RBRAC
          {
             pc const &from_pc = eg_pc_pool.get($2);
             pc const &to_pc = eg_pc_pool.get($4);
             edge_id_t<pc> eid(from_pc,to_pc);
             eg_cur_ec = eg_ec_pool.reg_elem(mk_edge_composition<pc,edge_id_t<pc>>(eid));
             $$ = eg_cur_ec;
          }
        | LBRAC edge_composition STAR edge_composition RBRAC
          {
            graph_edge_composition_ref<pc,edge_id_t<pc>> const &e1 = eg_ec_pool.get($2);
            graph_edge_composition_ref<pc,edge_id_t<pc>> const &e2 = eg_ec_pool.get($4);
            eg_cur_ec = eg_ec_pool.reg_elem(mk_series<pc,edge_id_t<pc>>(e1, e2));
            $$ = eg_cur_ec;
          }
        | LBRAC edge_composition PLUS edge_composition RBRAC
          {
            graph_edge_composition_ref<pc,edge_id_t<pc>> const &e1 = eg_ec_pool.get($2);
            graph_edge_composition_ref<pc,edge_id_t<pc>> const &e2 = eg_ec_pool.get($4);
            eg_cur_ec = eg_ec_pool.reg_elem(graph_edge_composition_construct_edge_from_parallel_edges<pc,edge_id_t<pc>>({ e1, e2 })); // mk_parallel does not preserve epsilon
            $$ = eg_cur_ec;
          }
        | LBRAC LABEL_EPSILON RBRAC
          {
             eg_cur_ec = eg_ec_pool.reg_elem(mk_epsilon_ec<pc,edge_id_t<pc>>());
             $$ = eg_cur_ec;
          }
;

label:   LABEL_INTERNAL
         {
           pool_id_t ret = eg_pc_pool.reg_elem(pc::create_from_string($1));
           free($1);
           $$ = ret;
         }
       | LABEL_EXIT
         {
           pool_id_t ret = eg_pc_pool.reg_elem(pc::create_from_string($1));
           free($1);
           $$ = ret;
         }
%%

namespace eqspace {

graph_edge_composition_ref<pc,edge_id_t<pc>>
parse_tfg_edge_composition(const char* str)
{
  //eg_tfg = &t;
// ltsin = stdin; // either use FD or yy_scan_string and yypop_buffer_state
// second one for cleaning the copy of str generated by flex
  eg_scan_string(str);

  int rc = egparse();

  egpop_buffer_state();
  graph_edge_composition_ref<pc,edge_id_t<pc>> ret = eg_ec_pool.get(eg_cur_ec);
  ASSERT(ret);
  eg_pc_pool.free_elems();
  eg_ec_pool.free_elems();
  return ret;
}

}

void egerror(const char* str)
{
  cerr << __func__ << " " << __LINE__ << ": Error! str = " << str << endl; assert(false);
}
